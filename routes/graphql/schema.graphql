"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-01-01 13:00:00`."
scalar DateTime
	@scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

# Protected Queries
type Query @middleware(checks: ["auth:api"]) {
	me: User! @auth
	# Upload URL
	uploadUrl(name: String!, bucket: String! @spread): UploadUrl!
		@field(resolver: "UploadUrlQuery")
}

# Public Queries
extend type Query {
	# Auth
	login(input: LoginInput!): LoginPayload @field(resolver: "LoginQuery")

	# Tracks
	tracks(page: Int = 1): [Track!]! @paginate(defaultCount: 20)
	track(hash: Int! @eq): Track @find

	# Users
	users(page: Int = 1): [User!]! @paginate(defaultCount: 20)
	user(id: ID! @eq): User @find

	# Genres
	genres(
		page: Int = 1
		orderBy: [OrderByClause!] = [{ field: "name", order: ASC }] @orderBy
	): [Genre!]! @paginate(defaultCount: 20)
	genre(slug: String! @eq): Genre @find

	# Artists
	artists(page: Int = 1): [Artist!]! @paginate(defaultCount: 20)
	artist(hash: ID @eq): Artist @find

	# Facebook Login URL
	facebookLoginUrl: facebookLoginUrl! @field(resolver: "FacebookLoginUrlQuery")
}

type Mutation @middleware(checks: ["auth:api"]) {
	# Auth
	logout: LogOutSuccess! @field(resolver: "LogOutMutation")
	updateUser(id: ID!, name: String): User @update
	deleteUser(id: ID!): User @delete
	addTrack(input: TrackInput!): Track @field(resolver: "CreateTrackMutation")
}

extend type Mutation {
	# Auth
	register(input: RegisterInput! @spread): User! @create
	handleFacebookConnect(code: String! @spread): facebookLoginPayload!
		@field(resolver: "HandleFacebookConnectMutation")
}

type facebookLoginUrl {
	url: String!
}

type LogOutSuccess {
	success: Boolean
}

type UploadUrl {
	signedUrl: String!
	fileUrl: String!
	filename: String!
}

input TrackInput {
	title: String!
	audioName: String!
	poster: String!
	detail: String
	lyrics: String
	audioFileSize: Int!
	artistId: Int!
	genreId: Int!
}

input RegisterInput {
	name: String! @rules(apply: ["required", "string"])
	email: String! @rules(apply: ["required", "email"])
	password: String! @rules(apply: ["required", "min:6"]) @bcrypt
	telephone: String @rules(apply: ["string"])
}

input LoginInput {
	email: String! @rules(apply: ["required", "email"])
	password: String!
		@rules(
			apply: ["required", "min:6"]
			messages: { min: "The password you provided is too short." }
		)
}

type LoginPayload {
	data: User!
	token: String!
}

type facebookLoginPayload {
	data: User!
	token: String!
	firstLogin: Boolean!
}

input OrderByClause {
	field: String!
	order: SortOrder!
}

enum SortOrder {
	ASC
	DESC
}

type User {
	id: ID!
	name: String!
	email: String
	avatar: String
	active: Boolean!
	tracks: [Track!]! @hasMany(type: "paginator", defaultCount: 20)
	telephone: String
	created_at: DateTime!
	updated_at: DateTime!
}

type Artist {
	id: ID!
	name: String!
	stage_name: String!
	hash: Int!
	avatar: String!
	tracks: [Track!]
}

type Track {
	id: ID!
	title: String!
	hash: Int!
	audio_name: String!
	post: String!
	featured: Boolean!
	detail: String!
	lyrics: String!
	genre: Genre! @belongsTo
	created_at: DateTime!
	updated_at: DateTime!
}

type Genre {
	id: ID!
	name: String!
	slug: String!
	tracks: [Track!]! @hasMany(type: "paginator", defaultCount: 20)
}
