# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

type Album {
    artist: Artist!
    cover_url: String!
    created_at: DateTime!
    detail: String!
    hash: Int!
    id: ID!
    release_year: DateTime!
    title: String!
    updated_at: DateTime!
    user: User!
}

type AlbumPaginator {
    data: [Album!]!
    paginatorInfo: PaginatorInfo!
}

type Artist {
    created_at: DateTime!
    facebook_url: String
    hash: Int!
    id: ID!
    instagram_url: String
    name: String!
    poster_url: String!
    stage_name: String!
    tracks(
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): TrackPaginator
    twitter_url: String
    updated_at: DateTime!
    user: User!
    youtube_url: String
}

type ArtistPaginator {
    data: [Artist!]!
    paginatorInfo: PaginatorInfo!
}

type Genre {
    created_at: DateTime!
    id: ID!
    name: String!
    slug: String!
    tracks(
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): TrackPaginator
    updated_at: DateTime!
}

type GenrePaginator {
    data: [Genre!]!
    paginatorInfo: PaginatorInfo!
}

type LogOutSuccess {
    success: Boolean
}

type LoginPayload {
    data: User!
    token: String!
}

type Mutation {
    addArtist(input: ArtistInput!): Artist!
    addGenre(input: GenreInput!): Genre!
    addTrack(input: TrackInput!): Track!
    createAlbum(input: AlbumInput!): Album!
    deleteUser(id: ID!): User
    handleFacebookConnect(code: String!): facebookLoginPayload!
    logout: LogOutSuccess!
    register(input: RegisterInput!): User!
    updateUser(id: ID!, name: String): User
}

type PageInfo {
    "Count of nodes in current request."
    count: Int
    "Current page of request."
    currentPage: Int
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Last page in connection."
    lastPage: Int
    "When paginating backwards, the cursor to continue."
    startCursor: String
    "Total number of node in connection."
    total: Int
}

type PaginatorInfo {
    "Total count of available items in the page."
    count: Int!
    "Current pagination page."
    currentPage: Int!
    "Index of first item in the current page."
    firstItem: Int
    "If collection has more pages."
    hasMorePages: Boolean!
    "Index of last item in the current page."
    lastItem: Int
    "Last page number of the collection."
    lastPage: Int!
    "Number of items per page in the collection."
    perPage: Int!
    "Total items available in the collection."
    total: Int!
}

type Query {
    albums(hash: ID): Album
    albumss(
        orderBy: [OrderByClause!],
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): AlbumPaginator
    artist(hash: ID): Artist
    artists(
        orderBy: [OrderByClause!],
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): ArtistPaginator
    facebookLoginUrl: facebookLoginUrl!
    genre(slug: String!): Genre
    genres(
        orderBy: [OrderByClause!] = [{field : "name", order : ASC}],
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): GenrePaginator
    login(input: LoginInput!): LoginPayload
    me: User!
    track(hash: Int!): Track
    tracks(
        orderBy: [OrderByClause!],
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): TrackPaginator
    uploadUrl(bucket: String!, name: String!): UploadUrl!
    user(id: ID!): User
    users(
        orderBy: [OrderByClause!],
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): UserPaginator
}

type Track {
    artist: Artist!
    audio_url: String!
    created_at: DateTime!
    detail: String!
    featured: Boolean!
    genre: Genre!
    hash: Int!
    id: ID!
    lyrics: String!
    number: Int!
    poster_url: String!
    title: String!
    updated_at: DateTime!
    user: User!
}

type TrackPaginator {
    data: [Track!]!
    paginatorInfo: PaginatorInfo!
}

type UploadUrl {
    filename: String!
    signedUrl: String!
}

type User {
    active: Boolean!
    albums(
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): ArtistPaginator
    artists(
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): TrackPaginator
    artists_by_stage_name_asc(
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): ArtistPaginator
    avatar: String
    created_at: DateTime!
    email: String
    id: ID!
    name: String!
    telephone: String
    tracks(
        #The offset from which elements are returned.
        page: Int,
        #Limits number of fetched elements. Maximum allowed value: 100.
        take: Int = 20
    ): TrackPaginator
    updated_at: DateTime!
}

type UserPaginator {
    data: [User!]!
    paginatorInfo: PaginatorInfo!
}

type facebookLoginPayload {
    data: User!
    firstLogin: Boolean!
    token: String!
}

type facebookLoginUrl {
    url: String!
}

enum SortOrder {
    ASC
    DESC
}

enum Trashed {
    ONLY
    WITH
    WITHOUT
}

input AlbumInput {
    artist_id: Int!
    cover: String!
    detail: String
    img_bucket: String!
    release_year: Int!
    title: String!
}

input ArtistInput {
    bio: String
    facebook: String
    img_bucket: String!
    instagram: String
    name: String!
    poster: String
    stage_name: String!
    twitter: String
    youtube: String
}

input GenreInput {
    name: String!
}

input LoginInput {
    email: String!
    password: String!
}

input OrderByClause {
    field: String!
    order: SortOrder!
}

input RegisterInput {
    email: String!
    name: String!
    password: String!
    telephone: String
}

input TrackInput {
    artistId: Int!
    audioFileSize: Int!
    audioName: String!
    audio_bucket: String!
    detail: String
    genreId: Int!
    img_bucket: String!
    lyrics: String
    number: Int
    poster: String!
    title: String!
}


"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-01-01 13:00:00`."
scalar DateTime

"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date